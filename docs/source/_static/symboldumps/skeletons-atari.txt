
Prog8 compiler v10.5 by Irmen de Jong (irmen@razorvine.net)
This software is licensed under the GNU GPL 3.0, see https://www.gnu.org/licenses/gpl.html

Compiling program import-all-atari.p8
Compiler target: atari


LIBRARY MODULE NAME: anyall
---------------------------

anyall  {
    all  (uword arrayptr, uword num_elements) -> bool 
    allw  (uword arrayptr, uword num_elements) -> bool 
    any  (uword arrayptr, uword num_elements) -> bool 
    anyw  (uword arrayptr, uword num_elements) -> bool 
}


LIBRARY MODULE NAME: buffers
----------------------------

smallringbuffer  {
    ubyte[]  buffer 
    ubyte  fill 
    ubyte  head 
    ubyte  tail 
    get  () -> ubyte 
    getw  () -> uword 
    init  () 
    put  (ubyte value) -> bool 
    putw  (uword value) -> bool 
}

ringbuffer  {
    uword  buffer_ptr 
    uword  fill 
    uword  head 
    uword  tail 
    get  () -> ubyte 
    getw  () -> uword 
    inc_head  () 
    inc_tail  () 
    init  () 
    put  (ubyte value) -> bool 
    putw  (uword value) -> bool 
}


LIBRARY MODULE NAME: compression
--------------------------------

compression  {
    decode_rle  (uword compressed @AY, uword target @R0, uword maxsize @R1) -> clobbers (X) -> uword @AY 
    decode_rle_srcfunc  (uword source_function @AY, uword target @R0, uword maxsize @R1) -> clobbers (X) -> uword @AY 
    encode_rle  (uword data, uword size, uword target, bool is_last_block) -> uword 
    encode_rle_outfunc  (uword data, uword size, uword output_function, bool is_last_block) 
}


LIBRARY MODULE NAME: conv
-------------------------

conv  {
    str @shared  string_out 
    any2uword  (str string @AY) -> clobbers (Y) -> ubyte @A 
    bin2uword  (str string @AY) -> uword @AY 
    hex2uword  (str string @AY) -> uword @AY 
    internal_byte2decimal  (byte value @A) -> ubyte @Y, ubyte @A, ubyte @X 
    internal_ubyte2decimal  (ubyte value @A) -> ubyte @Y, ubyte @X, ubyte @A 
    internal_ubyte2hex  (ubyte value @A) -> clobbers (X) -> ubyte @A, ubyte @Y 
    internal_uword2decimal  (uword value @AY) -> ubyte @Y, ubyte @A, ubyte @X 
    internal_uword2hex  (uword value @AY) -> clobbers (A,Y) 
    str2byte  (str string @AY) -> clobbers (Y) -> byte @A 
    str2ubyte  (str string @AY) -> clobbers (Y) -> ubyte @A 
    str2uword  (str string @AY) -> uword @AY 
    str2word  (str string @AY) -> word @AY 
    str_b  (byte value @A) -> clobbers (X) -> str @AY 
    str_ub  (ubyte value @A) -> clobbers (X) -> str @AY 
    str_ub0  (ubyte value @A) -> clobbers (X) -> str @AY 
    str_ubbin  (ubyte value @A) -> clobbers (X) -> str @AY 
    str_ubhex  (ubyte value @A) -> clobbers (X) -> str @AY 
    str_uw  (uword value @AY) -> clobbers (X) -> str @AY 
    str_uw0  (uword value @AY) -> clobbers (X) -> str @AY 
    str_uwbin  (uword value @AY) -> clobbers (X) -> str @AY 
    str_uwhex  (uword value @AY) -> str @AY 
    str_w  (word value @AY) -> clobbers (X) -> str @AY 
}


LIBRARY MODULE NAME: cx16logo
-----------------------------

cx16logo  {
    uword[]  logo_lines 
    logo  () 
    logo_at  (ubyte column, ubyte row) 
}


LIBRARY MODULE NAME: diskio
---------------------------

diskio  {
    const ubyte  READ_IO_CHANNEL 
    const ubyte  WRITE_IO_CHANNEL 
    ubyte @shared  drivenumber 
    bool  iteration_in_progress 
    uword  list_blocks 
    str  list_filename 
    str  list_filetype 
    uword  list_pattern 
    bool  list_skip_disk_name 
    bool  write_iteration_in_progress 
    delete  (uword filenameptr) 
    directory  () -> bool 
    diskname  () -> uword 
    exists  (str filename) -> bool 
    f_close  () 
    f_close_w  () 
    f_open  (uword filenameptr) -> bool 
    f_open_w  (uword filenameptr) -> bool 
    f_read  (uword bufferpointer, uword num_bytes) -> uword 
    f_read_all  (uword bufferpointer) -> uword 
    f_readline  (uword bufptr @AY) -> clobbers (X) -> ubyte @Y, ubyte @A 
    f_write  (uword bufferpointer, uword num_bytes) -> bool 
    lf_end_list  () 
    lf_next_entry  () -> bool 
    lf_start_list  (uword pattern_ptr) -> bool 
    list_filenames  (uword pattern_ptr, uword filenames_buffer, uword filenames_buf_size) -> ubyte 
    load  (uword filenameptr, uword address_override) -> uword 
    load_raw  (uword filenameptr, uword start_address) -> uword 
    rename  (uword oldfileptr, uword newfileptr) 
    reset_read_channel  () 
    reset_write_channel  () 
    save  (uword filenameptr, uword start_address, uword savesize) -> bool 
    send_command  (uword commandptr) 
    status  () -> uword 
    status_code  () -> ubyte 
}


LIBRARY MODULE NAME: math
-------------------------

math  {
    atan2  (ubyte x1 @R0, ubyte y1 @R1, ubyte x2 @R2, ubyte y2 @R3) -> ubyte @A 
    cos8  (ubyte angle @A) -> clobbers (Y) -> byte @A 
    cos8u  (ubyte angle @A) -> clobbers (Y) -> ubyte @A 
    cosr8  (ubyte radians @A) -> clobbers (Y) -> byte @A 
    cosr8u  (ubyte radians @A) -> clobbers (Y) -> ubyte @A 
    crc16  (uword data, uword length) -> uword 
    crc16_end  () -> uword 
    crc16_start  () 
    crc16_update  (ubyte value @A) 
    crc32  (uword data, uword length) 
    crc32_end  () 
    crc32_start  () 
    crc32_update  (ubyte value @A) 
    diff  (ubyte v1 @A, ubyte v2 @Y) -> ubyte @A 
    diffw  (uword w1 @R0, uword w2 @AY) -> uword @AY 
    direction  (ubyte x1, ubyte y1, ubyte x2, ubyte y2) -> ubyte 
    direction_qd  (ubyte quadrant @A, ubyte xdelta @X, ubyte ydelta @Y) -> ubyte @A 
    direction_sc  (byte x1, byte y1, byte x2, byte y2) -> ubyte 
    lerp  (ubyte v0, ubyte v1, ubyte t) -> ubyte 
    log2  (ubyte value @A) -> ubyte @Y 
    log2w  (uword value @AY) -> ubyte @Y 
    mul16_last_upper  () -> uword @AY 
    randrange  (ubyte n) -> ubyte 
    randrangew  (uword n) -> uword 
    rnd  () -> clobbers (Y) -> ubyte @A 
    rndseed  (uword seed1 @AY, uword seed2 @R0) -> clobbers (A,Y) 
    rndw  () -> uword @AY 
    sin8  (ubyte angle @A) -> clobbers (Y) -> byte @A 
    sin8u  (ubyte angle @A) -> clobbers (Y) -> ubyte @A 
    sinr8  (ubyte radians @A) -> clobbers (Y) -> byte @A 
    sinr8u  (ubyte radians @A) -> clobbers (Y) -> ubyte @A 
}


LIBRARY MODULE NAME: string
---------------------------

string  {
    append  (uword target @R0, uword suffix @R1) -> clobbers (Y) -> ubyte @A 
    compare  (uword string1 @R0, uword string2 @AY) -> clobbers (Y) -> byte @A 
    contains  (uword string @AY, ubyte character @X) -> bool @Pc 
    copy  (uword source @R0, uword target @AY) -> clobbers (A) -> ubyte @Y 
    endswith  (str st, str suffix) -> bool 
    find  (uword string @AY, ubyte character @X) -> ubyte @A, bool @Pc 
    findstr  (str haystack, str needle) -> ubyte 
    hash  (str string @R0) -> ubyte @A 
    isdigit  (ubyte petsciichar @A) -> bool @Pc 
    isletter  (ubyte petsciichar @A) -> bool @Pc 
    islower  (ubyte petsciichar @A) -> bool @Pc 
    isprint  (ubyte petsciichar @A) -> bool @Pc 
    isspace  (ubyte petsciichar @A) -> bool @Pc 
    isupper  (ubyte petsciichar @A) -> bool @Pc 
    left  (uword source @AX, ubyte length @Y, uword target @R1) -> clobbers (A,Y) 
    length  (uword string @AY) -> clobbers (A) -> ubyte @Y 
    lower  (uword st @AY) -> ubyte @Y 
    lowerchar  (ubyte character @A) -> ubyte @A 
    lstrip  (str s) 
    lstripped  (str s) -> str 
    ltrim  (str s) 
    ltrimmed  (str s) -> str 
    pattern_match  (str string @AY, str pattern @R0) -> clobbers (Y) -> bool @A 
    rfind  (uword string @AY, ubyte character @X) -> ubyte @A, bool @Pc 
    right  (uword source @AY, ubyte length @X, uword target @R1) -> clobbers (A,Y) 
    rstrip  (str s) 
    rtrim  (str s) 
    slice  (uword source @R0, ubyte start @A, ubyte length @Y, uword target @R1) -> clobbers (A,Y) 
    startswith  (str st, str prefix) -> bool 
    strip  (str s) 
    trim  (str s) 
    upper  (uword st @AY) -> ubyte @Y 
    upperchar  (ubyte character @A) -> ubyte @A 
}


LIBRARY MODULE NAME: syslib
---------------------------

atari  {
    &uword  COLCRS 
    &uword  IRQ_VEC 
    &uword  NMI_VEC 
    &uword  RESET_VEC 
    &ubyte  ROWCRS 
    getchar  () -> ubyte @A  = $f24a
    outchar  (ubyte character @A)  = $f2b0
    waitkey  () -> ubyte @A  = $f2fd
}

sys  {
    const ubyte  sizeof_bool 
    const ubyte  sizeof_byte 
    const ubyte  sizeof_float 
    const ubyte  sizeof_ubyte 
    const ubyte  sizeof_uword 
    const ubyte  sizeof_word 
    const ubyte  target 
    clear_carry  () 
    clear_irqd  () 
    disable_caseswitch  () 
    enable_caseswitch  () 
    exit  (ubyte returnvalue @A) 
    exit2  (ubyte resulta @A, ubyte resultx @X, ubyte resulty @Y) 
    exit3  (ubyte resulta @A, ubyte resultx @X, ubyte resulty @Y, bool carry @Pc) 
    internal_stringcopy  (uword source @R0, uword target @AY) -> clobbers (A,Y) 
    irqsafe_clear_irqd  () 
    irqsafe_set_irqd  () 
    memcmp  (uword address1 @R0, uword address2 @R1, uword size @AY) -> byte @A 
    memcopy  (uword source @R0, uword target @R1, uword count @AY) -> clobbers (A,X,Y) 
    memset  (uword mem @R0, uword numbytes @R1, ubyte value @A) -> clobbers (A,X,Y) 
    memsetw  (uword mem @R0, uword numwords @R1, uword value @AY) -> clobbers (A,X,Y) 
    pop  () -> ubyte @A 
    popw  () -> uword @AY 
    progend  () -> uword @AY 
    push  (ubyte value @A) 
    pushw  (uword value @AY) 
    read_flags  () -> ubyte @A 
    reset_system  () 
    restore_prog8_internals  () 
    save_prog8_internals  () 
    set_carry  () 
    set_irqd  () 
    wait  (uword jiffies) 
    waitvsync  () -> clobbers (A) 
}

cx16  {
    &uword  r0 
    &ubyte  r0H 
    &ubyte  r0L 
    &word  r0s 
    &byte  r0sH 
    &byte  r0sL 
    &uword  r1 
    &uword  r10 
    &ubyte  r10H 
    &ubyte  r10L 
    &word  r10s 
    &byte  r10sH 
    &byte  r10sL 
    &uword  r11 
    &ubyte  r11H 
    &ubyte  r11L 
    &word  r11s 
    &byte  r11sH 
    &byte  r11sL 
    &uword  r12 
    &ubyte  r12H 
    &ubyte  r12L 
    &word  r12s 
    &byte  r12sH 
    &byte  r12sL 
    &uword  r13 
    &ubyte  r13H 
    &ubyte  r13L 
    &word  r13s 
    &byte  r13sH 
    &byte  r13sL 
    &uword  r14 
    &ubyte  r14H 
    &ubyte  r14L 
    &word  r14s 
    &byte  r14sH 
    &byte  r14sL 
    &uword  r15 
    &ubyte  r15H 
    &ubyte  r15L 
    &word  r15s 
    &byte  r15sH 
    &byte  r15sL 
    &ubyte  r1H 
    &ubyte  r1L 
    &word  r1s 
    &byte  r1sH 
    &byte  r1sL 
    &uword  r2 
    &ubyte  r2H 
    &ubyte  r2L 
    &word  r2s 
    &byte  r2sH 
    &byte  r2sL 
    &uword  r3 
    &ubyte  r3H 
    &ubyte  r3L 
    &word  r3s 
    &byte  r3sH 
    &byte  r3sL 
    &uword  r4 
    &ubyte  r4H 
    &ubyte  r4L 
    &word  r4s 
    &byte  r4sH 
    &byte  r4sL 
    &uword  r5 
    &ubyte  r5H 
    &ubyte  r5L 
    &word  r5s 
    &byte  r5sH 
    &byte  r5sL 
    &uword  r6 
    &ubyte  r6H 
    &ubyte  r6L 
    &word  r6s 
    &byte  r6sH 
    &byte  r6sL 
    &uword  r7 
    &ubyte  r7H 
    &ubyte  r7L 
    &word  r7s 
    &byte  r7sH 
    &byte  r7sL 
    &uword  r8 
    &ubyte  r8H 
    &ubyte  r8L 
    &word  r8s 
    &byte  r8sH 
    &byte  r8sL 
    &uword  r9 
    &ubyte  r9H 
    &ubyte  r9L 
    &word  r9s 
    &byte  r9sH 
    &byte  r9sL 
    cpu_is_65816  () -> bool 
    restore_virtual_registers  () -> clobbers (A,Y) 
    save_virtual_registers  () -> clobbers (A,Y) 
}

p8_sys_startup  {
    cleanup_at_exit  () 
    init_system  () 
    init_system_phase2  () 
}


LIBRARY MODULE NAME: test_stack
-------------------------------

test_stack  {
    test  () 
}


LIBRARY MODULE NAME: textio
---------------------------

txt  {
    const ubyte  DEFAULT_HEIGHT 
    const ubyte  DEFAULT_WIDTH 
    bell  () 
    chrout  (ubyte character @A) 
    clear_screen  () 
    clear_screenchars  (ubyte character @A) -> clobbers (Y) 
    clear_screencolors  (ubyte color @A) -> clobbers (Y) 
    cls  () 
    color  (ubyte txtcol) 
    column  (ubyte col) 
    fill_screen  (ubyte character @A, ubyte color @Y) -> clobbers (A) 
    get_column  () -> ubyte 
    get_cursor  (uword colptr, uword rowptr) 
    get_row  () -> ubyte 
    getchr  (ubyte col @A, ubyte row @Y) -> clobbers (Y) -> ubyte @A 
    getclr  (ubyte col @A, ubyte row @Y) -> clobbers (Y) -> ubyte @A 
    height  () -> clobbers (X,Y) -> ubyte @A 
    input_chars  (uword buffer @AY) -> clobbers (A) -> ubyte @Y 
    lowercase  () 
    nl  () 
    plot  (ubyte col, ubyte rownum) 
    print  (str text @AY) -> clobbers (A,Y) 
    print_b  (byte value @A) -> clobbers (A,X,Y) 
    print_ub  (ubyte value @A) -> clobbers (A,X,Y) 
    print_ub0  (ubyte value @A) -> clobbers (A,X,Y) 
    print_ubbin  (ubyte value @A, bool prefix @Pc) -> clobbers (A,X,Y) 
    print_ubhex  (ubyte value @A, bool prefix @Pc) -> clobbers (A,X,Y) 
    print_uw  (uword value @AY) -> clobbers (A,X,Y) 
    print_uw0  (uword value @AY) -> clobbers (A,X,Y) 
    print_uwbin  (uword value @AY, bool prefix @Pc) -> clobbers (A,X,Y) 
    print_uwhex  (uword value @AY, bool prefix @Pc) -> clobbers (A,X,Y) 
    print_w  (word value @AY) -> clobbers (A,X,Y) 
    row  (ubyte rownum) 
    scroll_down  (bool alsocolors @Pc) -> clobbers (A) 
    scroll_left  (bool alsocolors @Pc) -> clobbers (A,Y) 
    scroll_right  (bool alsocolors @Pc) -> clobbers (A) 
    scroll_up  (bool alsocolors @Pc) -> clobbers (A) 
    setcc  (ubyte col, ubyte row, ubyte char, ubyte charcolor) 
    setchr  (ubyte col @X, ubyte row @Y, ubyte character @A) -> clobbers (A,Y) 
    setclr  (ubyte col @X, ubyte row @Y, ubyte color @A) -> clobbers (A,Y) 
    spc  () 
    uppercase  () 
    waitkey  () -> ubyte @A 
    width  () -> clobbers (X,Y) -> ubyte @A 
}


